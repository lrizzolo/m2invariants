needsPackage "InvariantRing"

--currently, this code only works with three variables (i.e. numVars = 0 and variables x_1, x_2, and x_3)
numVars = 3
R = QQ[x_1..x_numVars]
W = matrix{{1,0,3},{0,5,1}}
d = {9,9}
--W = matrix{{1,0,1},{0,1,1}}
--d = {17,17}
print W
T = diagonalAction(W, d, R)
print T
print cyclicFactors T

-- I compute the whole minimal generating set here just so that I can take one of the elements from the set
-- Then, I can use that one element to regenerate the rest of the set in the array M.
S1 = invariants T
S1 = sort S1

print "\nMinimal generating set of monomials computed by InvariantRing: "
print S1;

-- there's two x_1's in this array to make it so that array indexing (which starts at 0) lines up with the variable indexing (which starts at 1)
modVars := apply({x_1, x_1, x_2, x_3}, m -> sub(m, ring T) )
<<"modVars:"<<endl<<modVars<<endl
-- this bit of code finds the first element of S1 that isn't a pure power, which will be a generator of the set
-- Quick edit: a higher degree term of S1 seems to work better in the Z9 x Z9 example, so maybe start at the end of the list?

--i = 0
--while ((degree(modVars#1, S1#i) * degree(modVars#2, S1#i) == 0) and (degree(modVars#1, S1#i) * degree(modVars#3, S1#i) == 0) and (degree(modVars#2, S1#i) * degree(modVars#3, S1#i) == 0)) do ( i = i+1;);
i = #S1-1
while ((degree(modVars#1, S1#i) * degree(modVars#2, S1#i) == 0) and (degree(modVars#1, S1#i) * degree(modVars#3, S1#i) == 0) and (degree(modVars#2, S1#i) * degree(modVars#3, S1#i) == 0)) do ( i = i-1;);
m0 := S1#i

print "\nGenerator: "
print m0;

-- m' will be our "accumulator" that we constantly multiply by m0
m' := m0

-- sets the degree that each exponent will be modded by.
-- this seems to work for Z/p x Z/p but I'm not sure about other groups.
modDegree := lcm(d#0,d#1)

-- M will be all of the elements in our group and N will include only minimal elements of M
M := {}
N := {}

-- add the pure power elements to M since they aren't generated by the three-variable elements.
-- This step feels kind of clumsy and artificial. I'd like to find some way to make it so we don't have to manually add these elements.
i = 1
while (i <= numVars) do (
    M = M | {(modVars#i)^(modDegree)};
    i = i + 1;
);

-- accumulate the powers of m0 
i = 0
while (i < modDegree) do ( 
    M = M | {m'};
    m' = m'* m0; 
    j = 1;

    -- mod by the pure powers of each variable
    while (j <= numVars) do (
        while (degree(modVars#j, m') > modDegree) do (
            m' = lift(m' / ((modVars#j)^(modDegree)), R);
        );
        j = j + 1;
    );
    i = i+1;
);

--remove duplicate monomials
M = unique(M)
M = sort(M)
print "Full group generated by m': ";
print M
print "\nDoes the group generated by m' contain the minimal generating set?"
print isSubset(S1, M);

-- remove nonminimal elements from the set
i = 0;
while (i < #M) do (
    -- we will check if m1 is minimal
    m1 = M#i;
    j = 0;

    -- assume m1 is minimal until we find another monomial that divides it
    isMinimal = true;

    -- since M is sorted and the while loops has j < i in it, we know that degree(m2) <= degree(m1), so m2 could divide m1. However, if j > i, m2 will never divide m1.
    while (j < i and isMinimal) do (
        m2 = M#j;

        -- if m2 divides m1, then m1 is not minimal
        if (degree(x_1, m1) >= degree(x_1, m2) and degree(x_2, m1) >= degree(x_2, m2) and degree(x_3, m1) >= degree(x_3, m2)) then isMinimal = false;

        j = j+1;
        );

        -- if m1 was not divided by any other monomial, add it to the minimal set
        if (isMinimal) then N = N | {m1};
        i = i+1;
    );

print "\nRemoved all nonminimal elements from the group generated by m':"
print N;
print "\nIs this the same set as the one found by InvariantRing?"
print (N == S1);
