needsPackage "InvariantRing"

--Def generating algorithm as a method that we can use
--@param Ring the ring in which we are working
--@param Matrix the weight matrix
--@param List the list of dimensions
genAlg = method()
genAlg (Ring,Matrix,List) := (r,mat,lis) ->(
    R = r;
    numVars = numgens R;
    type = coefficientRing R;
    
    R = consoleRing(toString(type), toString numVars);
    
    W = matrix mat;
    d = lis;
    <<"\n Weight Matrix:\n"<<W;
    T = diagonalAction(W,d,R);
    <<"\nDiagonalAction:\n"<<T;
    <<"Cyclic factors:\n"<<cyclicFactors T << endl;
    
    -- I compute the whole minimal generating set here just so that I can take one of the elements from the set
    -- Then, I can use that one element to regenerate the rest of the set in the array M.
    S1 = invariants T;
    S1 = sort S1;

    <<"\nMinimal generating set of monomials computed by InvariantRing: ";
    <<S1;

    -- there's two x_1's in this array to make it so that array indexing (which starts at 0) lines up with the variable indexing (which starts at 1)
    modVars = apply({x_1, x_1, x_2, x_3}, m -> sub(m, ring T) );
    <<endl<<modVars<<endl;
    -- this bit of code finds the first element of S1 that isn't a pure power, which will be a generator of the set
    -- Quick edit: a higher degree term of S1 seems to work better in the Z9 x Z9 example, so maybe start at the end of the list?

    --i = 0;
    --while ((degree(modVars#1, S1#i) * degree(modVars#2, S1#i) == 0) and (degree(modVars#1, S1#i) * degree(modVars#3, S1#i) == 0) and (degree(modVars#2, S1#i) * degree(modVars#3, S1#i) == 0)) do ( i = i+1;);
    i = #S1-1;
    while ((degree(modVars#1, S1#i) * degree(modVars#2, S1#i) == 0) and (degree(modVars#1, S1#i) * degree(modVars#3, S1#i) == 0) and (degree(modVars#2, S1#i) * degree(modVars#3, S1#i) == 0)) do ( i = i-1;);
    m0 = S1#i;

    print "\nGenerator: ";
    print m0;

    -- m' will be our "accumulator" that we constantly multiply by m0
    m' := m0;

    -- sets the degree that each exponent will be modded by.
    -- this seems to work for Z/p x Z/p but I'm not sure about other groups.
    modDegree := lcm(d#0,d#1);

    -- M will be all of the elements in our group and N will include only minimal elements of M
    M := {};
    N := {};

    -- add the pure power elements to M since they aren't generated by the three-variable elements.
    -- This step feels kind of clumsy and artificial. I'd like to find some way to make it so we don't have to manually add these elements.
    i = 1;
    while (i <= numVars) do (
        M = M | {(modVars#i)^(modDegree)};
        i = i + 1;
    );

    -- accumulate the powers of m0
    i = 0;
    while (i < modDegree) do (
        M = M | {m'};
        m' = m'* m0;
        j = 1;

        -- mod by the pure powers of each variable
        while (j <= numVars) do (
            while (degree(modVars#j, m') > modDegree) do (
                m' = lift(m' / ((modVars#j)^(modDegree)), R);
            );
            j = j + 1;
        );
        i = i+1;
    );

    --remove duplicate monomials
    M = unique(M);
    M = sort(M);
    print "Full group generated by m': ";
    print M;
    print "\nDoes the group generated by m' contain the minimal generating set?";
    print isSubset(S1, M);

    -- remove nonminimal elements from the set
    i = 0;
    while (i < #M) do (
        -- we will check if m1 is minimal
        m1 = M#i;
        j = 0;

        -- assume m1 is minimal until we find another monomial that divides it
        isMinimal = true;

        -- since M is sorted and the while loops has j < i in it, we know that degree(m2) <= degree(m1), so m2 could divide m1. However, if j > i, m2 will never divide m1.
        while (j < i and isMinimal) do (
            m2 = M#j;

            -- if m2 divides m1, then m1 is not minimal
            if (degree(x_1, m1) >= degree(x_1, m2) and degree(x_2, m1) >= degree(x_2, m2) and degree(x_3, m1) >= degree(x_3, m2)) then isMinimal = false;

            j = j+1;
            );

            -- if m1 was not divided by any other monomial, add it to the minimal set
            if (isMinimal) then N = N | {m1};
            i = i+1;
        );

    print "\nRemoved all nonminimal elements from the group generated by m':";
    print N;
    print "\nIs this the same set as the one found by InvariantRing?";
    print (N == S1);

)

--Def Derksen-Gandini Algorithm as a method
--@param Ring the ring in which we are working
--@param Matrix the weight matrix
--@param List the list of dimensions
dGAlg = method()
dGAlg (Ring,Matrix,List) := (r,mat,lis) ->(
    R = r;
    W = matrix mat;
    d = lis;
    <<W;
    T = diagonalAction(W,d,R);
    <<T;
    <<cyclicFactors T;
)

